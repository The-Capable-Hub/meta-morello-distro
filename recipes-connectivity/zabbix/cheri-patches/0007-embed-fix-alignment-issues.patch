From 278989e4c3acee4e329fd83f1c1149d8a332459b Mon Sep 17 00:00:00 2001
From: Pawel Zalewski <pzalewski@thegoodpenguin.co.uk>
Date: Tue, 28 Nov 2023 09:50:06 +0000
Subject: [PATCH 07/10] embed: fix alignment issues

The zabbix internal embed allocators will take a properly aligned
pointer, cast it to u64 pointer store the allocated size in its
first memory chunk and then use u64 pointer aritchmetic to increment the
pointer. This is then returned as the base address for the allocated heap.

In CHERI this means that the base adress of the memory area which is then
interpreted as an address of a capability will be misalligned as
mod 16 will not be zero. This can be fixed by using align/up down but
preferably a data object should be created here with [.size, .pdata]

Signed-off-by: Pawel Zalewski <pzalewski@thegoodpenguin.co.uk>
---
 src/libs/zbxembed/embed.c | 39 +++++++++++++++++++++++++++++++++++++--
 1 file changed, 37 insertions(+), 2 deletions(-)

diff --git a/src/libs/zbxembed/embed.c b/src/libs/zbxembed/embed.c
index 187ef0edc19..f0b4b5eabff 100644
--- a/src/libs/zbxembed/embed.c
+++ b/src/libs/zbxembed/embed.c
@@ -39,6 +39,22 @@
 #define ZBX_ES_SCRIPT_HEADER	"function(value){"
 #define ZBX_ES_SCRIPT_FOOTER	"\n}"
 
+#if __has_builtin(__builtin_align_up)
+#define TYPEALIGN(ALIGNVAL,LEN)  \
+	(__builtin_align_up((LEN), ALIGNVAL))
+#else
+#define TYPEALIGN(ALIGNVAL,LEN)  \
+	(((uintptr_t) (LEN) + ((ALIGNVAL) - 1)) & ~((uintptr_t) ((ALIGNVAL) - 1)))
+#endif
+
+#if __has_builtin(__builtin_align_down)
+#define TYPEALIGN_DOWN(ALIGNVAL,LEN)  \
+	(__builtin_align_down((LEN), ALIGNVAL))
+#else
+#define TYPEALIGN_DOWN(ALIGNVAL,LEN) \
+	(((uintptr_t) (LEN)) & ~((uintptr_t) ((ALIGNVAL) - 1)))
+#endif
+
 /******************************************************************************
  *                                                                            *
  * Function: es_handle_error                                                  *
@@ -61,6 +77,8 @@ static void	es_handle_error(void *udata, const char *msg)
  * Memory allocation routines to track and limit script memory usage.
  */
 
+#define ALLOC_LOG_LEVEL  42
+
 static void	*es_malloc(void *udata, duk_size_t size)
 {
 	zbx_es_env_t	*env = (zbx_es_env_t *)udata;
@@ -76,8 +94,14 @@ static void	*es_malloc(void *udata, duk_size_t size)
 
 	env->total_alloc += (size + ZBX_ES_PAD);
 	uptr = zbx_malloc(NULL, size + ZBX_ES_PAD);
+
+  zabbix_log( ALLOC_LOG_LEVEL	, "==== [%p] Allocated %d, total alloc [%d]", uptr, size + ZBX_ES_PAD, env->total_alloc);
+
 	*uptr++ = size;
 
+  uptr = TYPEALIGN(16,uptr);
+  zabbix_log( ALLOC_LOG_LEVEL	, "==== Returning %p ", uptr);
+
 	return uptr;
 }
 
@@ -89,7 +113,7 @@ static void	*es_realloc(void *udata, void *ptr, duk_size_t size)
 
 	if (NULL != uptr)
 	{
-		--uptr;
+		uptr = TYPEALIGN_DOWN(16,--uptr);
 		old_size = *uptr + ZBX_ES_PAD;
 	}
 	else
@@ -105,8 +129,14 @@ static void	*es_realloc(void *udata, void *ptr, duk_size_t size)
 
 	env->total_alloc += size + ZBX_ES_PAD - old_size;
 	uptr = zbx_realloc(uptr, size + ZBX_ES_PAD);
+
+  zabbix_log( ALLOC_LOG_LEVEL	, "==== [%p] Reallocated %d, total alloc [%d]",uptr, size + ZBX_ES_PAD, env->total_alloc);
+
 	*uptr++ = size;
 
+  uptr = TYPEALIGN(16,uptr);
+  zabbix_log( ALLOC_LOG_LEVEL	, "==== Returning %p ", uptr);
+
 	return uptr;
 }
 
@@ -117,7 +147,12 @@ static void	es_free(void *udata, void *ptr)
 
 	if (NULL != ptr)
 	{
-		env->total_alloc -= (*(--uptr) + ZBX_ES_PAD);
+    uptr = TYPEALIGN_DOWN(16,--uptr);
+
+    env->total_alloc -= (*uptr + ZBX_ES_PAD);
+
+    zabbix_log( ALLOC_LOG_LEVEL, "==== [%p] Freed %d, total alloc [%d]", uptr, *uptr + ZBX_ES_PAD, env->total_alloc);
+
 		zbx_free(uptr);
 	}
 }
-- 
2.47.1

